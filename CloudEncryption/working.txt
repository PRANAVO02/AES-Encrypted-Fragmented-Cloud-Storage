encrypt_and_upload.py

import os
import json
import uuid
import dropbox
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from config import ACCESS_TOKEN, DROPBOX_FOLDER, AES_KEY_FILE, FRAGMENT_FOLDER

# --- Load AES key ---
with open(AES_KEY_FILE, "rb") as f:
    aes_key = f.read()

# --- Initialize Dropbox client ---
dbx = dropbox.Dropbox(ACCESS_TOKEN)

# --- Get file to upload ---
file_path = input("Enter path of file to upload: ").strip()
filename = os.path.basename(file_path)  # e.g., "demo.txt"

# --- Create fragment folder if not exists ---
os.makedirs(FRAGMENT_FOLDER, exist_ok=True)

# --- AES encryption ---
def aes_encrypt(plaintext, key):
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    encryptor = cipher.encryptor()
    padder = padding.PKCS7(128).padder()
    padded = padder.update(plaintext) + padder.finalize()
    ciphertext = encryptor.update(padded) + encryptor.finalize()
    return iv + ciphertext

# --- Read file ---
with open(file_path, "rb") as f:
    data = f.read()

# --- Safe fragment splitting ---
def split_file(data, num_fragments=4):
    length = len(data)
    fragments = []
    base_size = length // num_fragments
    remainder = length % num_fragments
    start = 0
    for i in range(num_fragments):
        extra = 1 if i < remainder else 0
        end = start + base_size + extra
        fragments.append(data[start:end])
        start = end
    return fragments

fragments = split_file(data, num_fragments=4)

# --- Encrypt & upload fragments ---
fragments_meta = []
for i, fragment in enumerate(fragments):
    encrypted = aes_encrypt(fragment, aes_key)

    # Random name for fragment
    frag_name = f"{uuid.uuid4().hex}.frag"

    # Save locally
    local_path = os.path.join(FRAGMENT_FOLDER, frag_name)
    with open(local_path, "wb") as f:
        f.write(encrypted)

    # Upload to Dropbox
    dropbox_path = f"{DROPBOX_FOLDER}/{frag_name}"
    with open(local_path, "rb") as f:
        dbx.files_upload(f.read(), dropbox_path, mode=dropbox.files.WriteMode.overwrite)

    fragments_meta.append({"index": i, "name": frag_name})
    print(f"Uploaded fragment {i} → {frag_name}")

# --- Save registry (all manifests in one file) ---
registry_file = "manifests.json"

# Load existing registry if present
if os.path.exists(registry_file):
    with open(registry_file, "r") as mf:
        registry = json.load(mf)
else:
    registry = {}

# Add / update this file’s manifest
registry[filename] = {
    "original_filename": filename,
    "total_fragments": len(fragments_meta),
    "fragments": fragments_meta,
}

# Save back to JSON locally
with open(registry_file, "w") as mf:
    json.dump(registry, mf, indent=2)

# Upload registry to Dropbox
with open(registry_file, "rb") as mf:
    dbx.files_upload(
        mf.read(),
        f"{DROPBOX_FOLDER}/manifests.json",
        mode=dropbox.files.WriteMode.overwrite
    )

print(f"\n✅ File '{filename}' uploaded in {len(fragments_meta)} fragments and added to registry.")


download_and_decrypt.py

import os
import json
import shutil
import dropbox
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding
from config import ACCESS_TOKEN, DROPBOX_FOLDER, DOWNLOAD_FOLDER, AES_KEY_FILE, RECONSTRUCTED_FOLDER

# --- Load AES key ---
with open(AES_KEY_FILE, "rb") as f:
    aes_key = f.read()

# --- Initialize Dropbox client ---
dbx = dropbox.Dropbox(ACCESS_TOKEN)

# --- Download registry (manifests.json) ---
manifest_path = f"{DROPBOX_FOLDER}/manifests.json"
metadata, res = dbx.files_download(manifest_path)
registry = json.loads(res.content)

# --- Show available files ---
print("\n📂 Available files in registry:")
for fname in registry.keys():
    print(" -", fname)

# --- Ask user which file to reconstruct ---
target_filename = input("\nEnter filename to reconstruct: ").strip()

if target_filename not in registry:
    print(f"❌ No manifest found for {target_filename}")
    exit()

manifest = registry[target_filename]
print("✅ Manifest loaded for:", target_filename)

# --- Clear & prepare download folder ---
if os.path.exists(DOWNLOAD_FOLDER):
    shutil.rmtree(DOWNLOAD_FOLDER)
os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)

# --- AES decrypt ---
def aes_decrypt(ciphertext, key):
    iv = ciphertext[:16]
    ct = ciphertext[16:]
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv))
    decryptor = cipher.decryptor()
    decrypted_padded = decryptor.update(ct) + decryptor.finalize()
    unpadder = padding.PKCS7(128).unpadder()
    return unpadder.update(decrypted_padded) + unpadder.finalize()

# --- Download fragments according to manifest ---
fragments = sorted(manifest["fragments"], key=lambda x: x["index"])
reconstructed_data = b""

for frag in fragments:
    frag_name = frag["name"]
    dropbox_path = f"{DROPBOX_FOLDER}/{frag_name}"
    local_path = os.path.join(DOWNLOAD_FOLDER, frag_name)

    metadata, res = dbx.files_download(dropbox_path)
    with open(local_path, "wb") as f:
        f.write(res.content)

    decrypted_fragment = aes_decrypt(res.content, aes_key)
    reconstructed_data += decrypted_fragment
    print(f"Downloaded + Decrypted {frag_name}")

# --- Save reconstructed file ---
os.makedirs(RECONSTRUCTED_FOLDER, exist_ok=True)

original_filename = manifest["original_filename"]
reconstructed_filename = f"reconstructed_{original_filename}"
reconstructed_path = os.path.join(RECONSTRUCTED_FOLDER, reconstructed_filename)

with open(reconstructed_path, "wb") as f:
    f.write(reconstructed_data)

print(f"\n✅ File reconstructed successfully as '{reconstructed_path}'")
